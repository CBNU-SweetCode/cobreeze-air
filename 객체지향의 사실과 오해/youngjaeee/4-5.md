## IV. 역할, 책임, 협력

### 1. 객체지향 설계 시에는 객체 간의 요청과 응답 속에서 발생하는 협력에 초점을 맞춰야 함.
		· 어떤 협력에 참여하는지가 객체의 필요한 행동을 결정하고, 행동이 상태 결정함. 
### 2. 협력은 객체가 다른 객체에 도움을 요청하고 응답하는 것으로 이루어짐. -> 연쇄적으로
		· 요청과 응답은 협력에 참여하는 객체가 수행할 책임을 정의함.
		· 책임: 어떤 객체가 요청에 대해 대답하거나 어떤 행동을 할 의무가 있는 경우 가짐.
		   		└ 책임을 능숙하게 소프트웨어 객체에 할당할 수 있어야 함.
		· 책임 → 하는 것(doing)
			- 객체 생성 or 계산 등 스스로 하는 것
			- 다른 객체 행동 시작시키는 것
			- 다른 객체 활동 제어 및 조절하는 것
		· 책임 → 아는 것(knowing)
			- 개인적인 정보에 관해 아는 것
			- 관련된 객체에 관해 아는 것
			- 자신이 유도하거나 계산할 수 있는 것에 대해 아는 것
### 3. 책임은 객체 외부에 제공하는 정보, 서비스 목록으로 공용 인터페이스를 구성함 → 캡슐화
### 4. 메시지 전송: 객체(송신자)가 다른 객체(수신자)에게 책임을 수행하도록 요청 보내는 것
		· 책임은 객체가 수행할 행위 개략적으로 서술, 하나의 책임이 여러 메시지로 분할됨.
		· 객체지향 설계는 객체의 책임과 메시지 송수신에 대한 윤곽을 먼저 잡고 시작함!
### 5. 역할: 동일한 책임의 집합을 수행하는 여러 객체를 역할 개념으로 포괄하여 추상화함.
		· 역할을 통해 객체지향 설계의 단순성, 유연성, 재사용성 뒷받침함.
		· 같은 역할을 가질 경우 해당 위치에 어떠한 객체도 대체 가능함. → 일반화/특수화
		   	   └ 역할이 객체의 추상화, 역할의 대체 가능성은 동일 책임 수행 의미
### 6. 객체지향 설계 시 객체가 참여할 문맥인 협력을 정의하고, 충분히 자율적이면서도 협력적인 객체 창조할 수 있어야 함.
### 7. 객체지향 설계 기법
		· 책임-주도 설계: 협력에 필요한 책임을 식별하여 적절한 객체에 할당하여 설계
			- 시스템 기능을 작은 책임으로 분할하여 여러 객체에 할당
			- 객체가 스스로 해결할 수 없는 문제는 다른 객체에 작업 요청 → 협력!
			- 개별적 객체 상태가 아닌 객체의 책임과 상호작용에 집중함
			     └ ⓵ 시스템 책임(제공할 기능) 파악
			     └ ⓶ 시스템 책임을 더 작은 책임으로 분할
			     └ ⓷ 분할된 책임 수행할 수 있는 객체, 역할 찾아 책임 할당
			     └ ⓸ 책임 수행 중 다른 객체 도움 필요할 경우 적절한 객체, 역할 찾음
			     └ ⓹ 해당 객체, 역할에 책임 할당하면서 협력하게 됨
		· 디자인 패턴: 반복적으로 사용하는 해결 방법 정의한 설계 템플릿 모음
			- 반복적으로 발생하는 문제와 해법의 쌍으로 구성, 책임-주도 설계 결과물
			- 공통으로 사용할 수 있는 역할, 책입, 협력 템플릿
		· 테스트-주도 개발: 테스트 먼저 작성하고 적합한 코드 추가하면서 완성하는 방식
			- 객체가 메시지 수신 시 어떤 결과 반환하고 어떻게 협력할지 기대를 코드로 작성
## V. 책임과 메시지

### 1. 객체지향 공동체를 구성하는 기본 단위는 자율적인 객체
		· 자율성: 스스로 정한 원칙에 따라 판단하고 자의를 기반으로 행동하는 성질
		· 자율적 객체는 스스로의 의지와 판단에 따라 맡은 책임을 수행함.
		· 책임을 너무 구체화할 경우 자율성 저하, 너무 추상화할 경우 협력 의도 부정확
			   └ 적절한 수준으로 구성하여 자율성과 유연성 높여야 함.
		· 자율적 책임은 객체가 ‘어떻게’ 하는 것 보다 ‘무엇을’ 하는 것에 초점
### 2. 메시지: 객체가 다른 객체에 접근할 유일한 방법으로 요청 전송하는 것(메시지-전송)
		· 메시지 이름과 인자(argument, 추가 정보 전달 위함)로 구성되어 있음
		· 객체가 메시지 수신할 수 있다는 것은 해당하는 책임 수행이 가능함을 의미
		· 객체가 수신할 수 있는 메시지의 모양이 객체가 수행할 책임의 모양 결정함.
		· 외부 객체는 메시지만 확인 가능, 객체 내부는 확인 불가 → 내외부 분리
### 3. 메소드: 객체가 외부 메시지를 처리하기 위해 내부적으로 선택하는 방법
		· 객체지향 언어에서는 클래스에 포함된 함수, 프로시저를 통해 구현됨
		· 객체는 메시지 수신 시 처리 가능 여부 확인 후 책임 수행 위해 적절한 메소드 선택
		· 프로시저 호출을 컴파일 시에 결정하는 절차지향 언어와 달리 런타임에 선택함!
### 3. 다형성: 서로 다른 유형의 객체가 같은 메시지에 서로 다르게 반응하는 성질
		· 같은 메시지에 대해 서로 다른 메소드를 통해 메시지를 처리하는 매커니즘
		· 서로 다른 객체가 다형성 만족시키는 것을 동일한 책임 공유하는 것을 의미
		· 동일한 역할을 수행할 수 있는 객체들 사이의 대체 가능성을 의미
			   └ 대체 가능성을 통해 설계 유연하게 하고 재사용성 높임.
		· 협력이 유연해지고 수행되는 방식 확장시킬 수 있으며, 수행되는 방식 재사용 가능!
		· 송신자와 수신자 사이 결합도를 낮추는 메시지를 통해 위와 같이 설계 가능함.
### 4. 메시지 세부사항
		· 클래스는 동적인 객체의 특성과 행위 표현 위한 추상화 도구일 뿐, 중요한 건 객체!
		· 메시지를 주고 받는 동적인 객체들의 속성과 행위 식별하면서 설계 시작해야!
 	        └ 메시지 아닌 데이터 중심으로 설계할 경우 객체 자율성 저해(데이터-주도 설계)
		· 메시지가 객체 선택하게 하는 관점에서 메시지 중심으로 협력 설계해야 함.
### 5. 책임-주도 설계 세부사항
		· 책임을 완수하기 위해 협력하는 객체를 이용하여 시스템을 설계하는 방법
		· 협력(도움) 요청 위해 어떤 메시지 필요한 지 결정 후, 요청할 적합한 객체 선택
		· 메시지가 수신자의 책임 결정하게 됨.
		· What/Who 사이클: 어떤 행위가 필요한 지 먼저 결정한 후 행위 수행할 객체 결정
 	     └ 협력이라는 문맥 안에서 객체의 책임을 결정하는 것은 메시지이다!
 	     └ Tell, Dont‘t Ask / 데메테르 법칙: 메시지를 먼저 결정 후 객체가 따르게 함
 	     └ 메시지 수신자의 캡슐화를 증진시키고 송신자와 수신자 느슨하게 결합시킴!
### 6. 인터페이스: 두 사물이 마주치는 경계 지점에서 상호작용할 수 있게 이어줌.
		· 인터페이스 사용법만 익히면 내부 구조나 원리 몰라도 쉽게 조작 가능
		· 인터페이스를 그대로 두고 내부 구조를 변경하면 외부 사용자에게 영향X
		· 대상이 변경돼도 인터페이스만 동일하다면 문제없이 상호작용 가능
		· 객체의 인터페이스는 수신할 수 있는 메시지의 목록으로 구성됨.
 	     └ 객체가 어떤 메시지를 수신할 수 있는지가 인터페이스 모양을 구성
		· 모든 인터페이스는 메시지 전송을 통해서만 접근 가능
### 7. 공용 인터페이스: 내부에서만 접근 가능한 사적 인터페이스 구분 위해 외부 공개된 부분
		· 객체가 협력하기 위해 수행하는 메시지가 공용 인터페이스의 모양을 암시함

### 8. 인터페이스 원칙
		· 좀 더 추상적인 인터페이스
 	     └ 세부 사항을 제거하고 메시지의 의도만을 표현하도록 추상화
		· 최소 인터페이스
 	     └ 인터페이스 외부 노출 최소화, 불필요한 메시지 없앰
	 	· 인터페이스와 구현의 분리 확실하게
 	     └ 구현: 내부 구조와 작동 방식, 객체를 구성하지만 공용 인터페이스에 포함X
 	     └ 구현을 내부에 감춤으로써 내부 구조 변경시 외부 영향 최소화, 캡슐화 달성
### 9. 캡슐화(정보 은닉): 상태와 행위의 캡슐화 / 사적인 비밀의 캡슐화
		· 상태와 행위의 캡슐화(data encapsulation)
 	     └ 상태와 행위를 묶은 후 외부에서 반드시 접근해야 하는 행위만 공용 인터페이스로
 	     └ 자율적인 객체를 만들기 위한 전제 조건(데이터와 프로세스 묶음)
		· 사적인 비밀의 캡슐화
 	     └ 내부 상태의 변경, 조작 등을 외부에서 모르게 감춤(공용 인터페이스 통해서)
 	     └ 외부의 불필요한 공격과 간섭으로부터 격리할 수 있음
		· 객체는 자율적인 책임을 가져야 하며, 책임을 결정하는 것은 메시지이다!
### 10. 자율적인 책임의 중요성
		· 자율적인 책임은 협력을 단순하게 만듦
		· 자율적인 책임은 객체의 외부와 내부를 명확하게 구분함.
 	     └ 캡슐화를 통한 인터페이스와 구현 구분
		· 자율적인 책임은 책임을 수행하는 내부 방법이 변경돼도 외부에 영향 안 미침.
 	     └ 캡슐화를 통한 객체 간 결합도 감소
		· 자율적인 책임은 협력의 대상을 다양하게 선택할 수 있는 유연성을 제공함
		· 객체가 수행하는 책임이 자율적일수록 객체 역할 이해하기 쉬워짐.