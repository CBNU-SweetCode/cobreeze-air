<객체지향의 사실 오해 1 ~ 3장 정리>
============================
### Notion address : https://pepper-salto-e83.notion.site/6441035bf79d489a8d73c5bcbf654ef3

## [1장] 협력하는 객체들의 공동체

- 시너지를 생각하라. 전체는 부분의 합보다 크다.
- 객체지향이란 실제 세계를 직접적이고 직관적으로 모델링 할 수 있는 패러다임이다.
- 실제 세계의 사물과 그것을 추상화하여 생긴 객체 사이에서 유사성을 찾기는 매우 어렵다.
    - ex) 음료수 클래스에서는 메소드를 통해 음료수의 양을 조절한다거나 마시거나, 버릴 수 있지만 현실의 음료수는 그저 존재하기만 할 뿐, 스스로 행동을 취할 수는 없다. 이 차이다.
- 객체지향에서 가장 중요한 개념 3가지 : **역할, 책임, 협력**
- 협력은 요청과 응답으로 구성되어 있다.
    - 요청과 응답은 연쇄적으로 발생한다

### — 협력은 역할과 책임으로 구성되어 있다.

- 역할이라는 단어는 의미적으로 책임이라는 개념을 내포한다.
- 객체의 역할과 사람의 역할 끼리 유사한 점
    - 여러 객체가 동일한 역할을 수행할 수 있다.
    - 역할은 대체가능성을 의미한다
    - 각 객체는 책임을 수행하는 방법을 자율적으로 선택 할 수 있다.
    - 하나의 객체가 동시에 여러 역할을 수행할 수 있다.
- **다형성 (polymorphism)**: 동일한 요청에 대해 서로 다른 방식으로 응답할 수 있는 능력

---

## [2장] 이상한 나라의 객체

- 소프트웨어의 세계 역시 인간이 인지할 수 있는 다양한 소프트웨어 객체들이 모여 이뤄져 있다는 믿음에서 출발한다. 그러나 객체지향 패러다임의 목적은 현실 세계를 모방하는 것이 아니라 현실세계를 기반으로 새로운 세계를 창조하는 것이기 때문에 소프트웨어 세계의 객체와 현실의 객체는 전혀 다른 모습이다.
- 객체 = 상태 + 행동 + 식별자

### —  상태

- 객체의 상태는 “단순한 값”과 객체의 조합으로 표현할 수 있다.
- **프로퍼티 (property)(정적)** : 객체의 상태를 구성하는 모든 특징
    - 프로퍼티는 속성(attribute)과 링크(link)라는 두가지 종류의 조합으로 표현할 수 있다.
- **프로퍼티 값 (property value)(동적)** = “단순한 값” = 속성(attribute)
- **링크(link)** : 객체와 객체 사이의 의미 있는 연결 / 객체가 다른 객체를 참조할 수 있음을 의미함
- 객체지향의 기본 사상 : 상태 + 상태를 조작하기위한 행동
- 객체는 스스로의 행동에 의해서만 상태가 변경되는 것을 보장함으로써 자율성을 유지한다.

### —  행동

- 객체의 행동은 상태에 영향을 받는다. (이전 상태로부터 변하기 때문)
- 객체의 행동은 상태를 변경시킨다.
- 행동의 결과
    - 객체 자신의 상태를 변경한다
    - 다른 객체에게 메시지를 전달한다.

### —  협력

- 객체가 다른 객체와 협력하는 유일한 방법 : 메시지
- 객체간의 협력은 행동을 통해서만 가능하다.

### — 상태 캡슐화

- 객체는 상태를 캡슐 안에 감춰둔 채 외부로 노출하지 않는다.

### [상태 캡슐화 → 객체의 자율성 증가 → 객체의 지능 증가 → “ 협력의 유연성, 간결성 증가 “]

---

### — 식별자

- **식별자** = 객체를 서로 구별할 수 있게 해주는 프로퍼티
- **값(value)  (= 값 객체)**
    - 불변상태 (Immutable state) - 상태가 변하지 않는다.
    - 동등성(equality) : 값의 상태가 같으면 두 인스턴스는 같음을 나타내는 성질
- **객체 (= 참조 객체, 엔티티)**
    - 가변상태 (Mutable state) - 상태가 시간에 따라 변한다.
    - 객체의 상태가 서로 같더라도 서로 독립적인 별개이다.
    - 동일성(identical) : 객체의 상태가 서로 다르더라도 식별자가 같다면 두 객체는 같다.
        
        ⇒ 사람이 어릴때와 나이가 들었을 때, 두 상태는 서로 많이 다르지만 결국 같은 사람이라는 것은 변하지 않는다. 이처럼 객체 또한 같은 객체임을 확인할 수 있는 것이 식별자이다.
        

### — 기계로서의 객체

- **쿼리(query)** : 객체의 상태를 조회
- **명령(command)** : 객체의 상태를 변경하는 작업
- 객체를 기계은유로 바라보면
    - 쿼리버튼(조회)
    - 명령버튼(상태변경)
    - 상태 캡슐화
    - 식별자 특성
    - 링크 연결 시, 메세지를 이용한 협력
    
    위와 같이 객체에 대해 포괄적이며 효과적으로 살펴볼 수 있는 장점이 있다.
    

### — “ 행동이 상태를 결정한다 “

- 객체를 만들때는 상태보다 행동을 중심으로 해야한다.
- 객체의 적합성을 결정하는 것은 상태가 아니라 행동이다.

### — 은유과 객체

- **추상화(abstraction)** : 실제의 사물에서 자신이 원하는 특성마나 취하고 필요 없는 부분을 추려 핵심만 표현하는 행위
- “객체지향이 현실을 오롯이 모방하기만 한다는 것은 오해일 뿐이다.” - 67page
- **의인화(anthropomorphism)** : 소프트웨어의 객체가 현실의 객체보다 더 많은 일을 할 수 있음을 의미한다.
- **은유(metaphor)** : 실제로는 적용되지 않는 한 가지 개념을 이용해 다른 개념을 서술하는 대화의 한 형태
- **차이(gap)** : SW에 대해 사람들이 생각하는 모습과 실제 SW표현 사이의 차이

### [ “ 소프트웨어의 객체는 현실의 객체를 이용해 은유적으로 표현된다. 이때, 표현적 차이 (representational gap) 또는, 의미적 차이(semantic gap)가 발생할 수 있는데 이를 줄이기 위해 우리는 객체지향 모델링을 할 때 객체의 이름을 정할 때 현실세계에서 사용되는 이름을 사용하는 것이다. “ ]

---

## [3장] 타입과 추상화

- 복잡성의 총체인 현실을 그대로 수용하기에는 인간이 지니고 있는 인지 능력과 저장 공간이 너무나도 보잘것없다. 그래서 사람들은 본능적으로 이해하기 쉽고 예측 가능한 수준으로 현실을 분해하고 단순화한다. 즉, 불필요한 부분을 무시함으로써 현실에 존재하는 복잡성을 극복하는 것이다.⇒ 추상화의 목적
- ‘헤리 벡’의 지하철 노선도는 불필요한 지형 정보를 제거함으로써 단순함을 달성한 추상화의 훌륭한 예시이다.
- 추상화의 두 차원
    1. 구체적인 사물들 간의 공통점은 취하고 차이점은 버리는 일반화를 통해 단순화한다.
    2. 중요한 부분을 강조하기 위해 불필요한 세부 사항을 제거함으로써 단순화한다.

### — 개념

- 공통점을 기반으로 객체들을 묶기 위한 그릇
- 일반적으로 우리가 인식하고 있는 다양한 사물이나 객체에 적용할 수 있는 아이디어나 관념
- 개념을 이용하면 객체를 여러 그룹으로 **분류(classification)**할 수 있다.
    - 이때, 객체가 개념 그룹의 일원이될 때, 객체를 그 개념의 **인스턴스(instance)**라고 한다.

**→ 복잡한 현실을 몇 개의 개념만으로 단순화 할 수 있다.**

- 개념의 3가지 관점
    1. **심볼Symbol** : 개념을 기리키는 간략한 이름이나 명칭
    2. **내연intension** : 개념의 완전한 정의를 나타내며 내연의 의미를 이용해 객체가 개념에 속하는지 여부를 확인할 수 있다.
    3. **외연extension** : 개념에 속하는 모든 객체의 집합set

### — 분류

- 특정한 객체를 특정한 개념의 객체 집합에 포함시키거나 포함시키지 않는 작업을 의미한다.
- 객체를 적절한 개념에 따라 분류한 애플리케이션은 유지보수가 용이하고 변경에 유연하게 대처할 수 있다.
- 분류는 위에서 언급한 추상화의 두 차원을 모두 만족한다.

### — 타입

- **타입type** = 개념
- 타입시스템type sytem
    - 메모리 안의 모든 데이터가 비트열로 보임으로써 야기되는 혼란을 방지한다.
    - 데이터가 잘못 사용되지 않도록 제약사항을 부과하는 것이다.
- 타입의 중요한 두 가지 사실
    1. 어떤 데이터에 어떤 연산자를 적용할 수 있느냐가 그 데이터의 타입을 결정한다
    2. 연산자를 알고 있다면 메모리 내부에 타입별로 어떻게 저장되는지를 모르더라도 연산에 맞는 데이터를 사용할 수 있다.
- 행동이 우선이다.
    - 어떤 객체를 다른 객체와 동일한 타입으로 분류하는 기준은?
        
        ⇒ 그 객체가 타입에 속한 다른 객체와 동일한 행동을 하기만 하면 된다.
        
    - 같은 타입의 객체들은 행동이 동일하다
        
        = 동일한 책임  = 동일한 메시지 수신  = 동일한 메시지를 수신하고 처리할 수 있다(처리방식은 다르다) 
        
        = 다형성
        
    - **다형성** : 동일한 요청에 대해 서로 다른 방식으로 응답할 수 있는 능력
        
        ⇒ 다형적인 객체들은 동일한 타입에 속하게 된다.
        
    - **캡슐화** : 외부에 행동만을 제공하고 데이터는 행동 뒤로 감춘다.
    - 행동에 따라 객체를 분류하는 순서
        1. 객체가 외부에 제공해야 하는 행동을 먼저 생각한다.
        2. 행동에 따르는 책임을 결정한다.
        3. 책임을 수행하는 데 적합한 데이터들을 다음으로 결정한다.
        4. 책임을 수행하는데 필요한 외부 인터페이스 뒤로 캡슐화한다.
    - **책임-주도 설계** : 이전의 데이터를 먼저 생각하는 데이터-주도 설계의 단점을 개선하기 위해 고안된 설계 방법이다.
- 일반화/특수화 관계(with Supertype & Subtype)
    - 한 타입이 다른 타입보다 더 특수하게 행동해야 하고 반대로 한 타입은 다른 타입보다 더 일반적으로 행동하는 관계 → 일반화/특수화 관계를 정하는 것은 결국 ‘행동' 이다.
    - **일반적인 타입(Supertype)** : 특수한 타입이 갖고있는 행동들 중에서 일부 행동만을 할 수 있다.
    - **특수한 타입(Subtype)** : 일반적인 타입이 가진 모든 행동을 포함하며 추가적으로 자신만의 행동을 할 수 있다.
    - “행동의 가짓수”와 “외연(집합의 크기)”는 서로 반비례한다.
- 타입은 시간에 따라 동적으로 변하는 객체의 상태를 시간과 무관한 정적인 모습으로 다룰 수 있게 해준다.
    
    = 타입은 시간에 따른 객체의 상태 변경이라는 복잡성을 단순화할 수 있는 효과적인 방법이다.
    
- 정적 모델과 동적모델
    - **동적 모델** : 실제로 객체가 살아 움직이는 동안의 상태 변화와 수행하는 행동을 포착하는 것
        
        → 스냅샷(객체가 특정 시점에 구체적으로 어떤 상태를 가지는가?)
        
        → 애플리케이션을 실행해 객체의 상태 변경을 추적하고 디버깅하는 시점
        
    - **정적 모델** : 객체가 속한 타입의 정적인 모습을 표현하는 것.
        
        → 타입 모델
        
        → 클래스를 작성하는 시점
        
    - 훌륭한 객체지향 프로그래머라면 애플리케이션의 동적/정적인 관점을 모두 다뤄야 한다.
- 클래스
    - 클래스는 타입이 아니다.
    

### [ “ 객체를 분류하는 기준은 타입이며, 타입을 나누는 기준은 객체가 수행하는 행동이다.그리고 프로그래밍 언어로 타입을 구현할 수 있는 방법 중 한 가지가 클래스이다. ” ]

---
